<!DOCTYPE html>
<html>
<head>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: #ffffff;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .header {
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      flex-shrink: 0;
    }

    h2 {
      font-size: 13px;
      font-weight: 600;
      margin: 0;
      color: #000000;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .left-panel {
      width: 300px;
      padding: 16px;
      border-right: 1px solid #e5e5e5;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }

    .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .upload-area {
      border: 2px dashed #d0d0d0;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .upload-area:hover {
      border-color: #18a0fb;
      background: #f7f7f7;
    }

    .upload-area.dragover {
      border-color: #18a0fb;
      background: #e5f3ff;
    }

    .upload-text {
      margin: 0 0 6px 0;
      font-size: 11px;
      color: #333333;
      font-weight: 500;
    }

    .upload-subtext {
      margin: 0;
      font-size: 10px;
      color: #999999;
    }

    #fileInput {
      display: none;
    }

    .preview-container {
      display: none;
      padding: 16px;
      flex-shrink: 0;
      background: #f7f7f7;
      border-bottom: 1px solid #e5e5e5;
      position: relative;
    }

    #imagePreview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 4px;
      display: block;
      margin: 0 auto;
    }

    #clusterCanvas {
      max-width: 100%;
      max-height: 200px;
      border-radius: 4px;
      display: none;
      margin: 0 auto;
      position: relative;
    }

    .cluster-corner {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 5;
      transition: all 0.3s ease;
    }

    .cluster-corner::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(255,255,255,0.5), transparent);
      opacity: 0.6;
    }

    .particle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 0 6px rgba(0,0,0,0.5), 0 0 12px currentColor;
      will-change: transform, opacity;
      border: 1px solid rgba(255,255,255,0.5);
    }

    .progress-dots::after {
      content: '';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: ''; }
      40% { content: '.'; }
      60% { content: '..'; }
      80%, 100% { content: '...'; }
    }

    @keyframes particleFloat {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      80% {
        transform: translate(var(--tx), var(--ty)) scale(0.7);
        opacity: 0.95;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0.3);
        opacity: 0;
      }
    }

    @keyframes cornerPulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
      50% {
        transform: scale(1.1);
        box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      }
    }

    .cluster-corner.pulsing {
      animation: cornerPulse 0.6s ease-in-out;
    }

    .color-item {
      animation: slideIn 0.3s ease backwards;
    }

    .color-item:nth-child(1) { animation-delay: 0.05s; }
    .color-item:nth-child(2) { animation-delay: 0.1s; }
    .color-item:nth-child(3) { animation-delay: 0.15s; }
    .color-item:nth-child(4) { animation-delay: 0.2s; }
    .color-item:nth-child(5) { animation-delay: 0.25s; }
    .color-item:nth-child(6) { animation-delay: 0.3s; }
    .color-item:nth-child(7) { animation-delay: 0.35s; }
    .color-item:nth-child(8) { animation-delay: 0.4s; }
    .color-item:nth-child(n+9) { animation-delay: 0.45s; }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .success-pulse {
      animation: successPulse 0.6s ease;
    }

    @keyframes successPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #18a0fb;
      border-radius: 50%;
      pointer-events: none;
      animation: sparkle 1s ease-out forwards;
    }

    @keyframes sparkle {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0);
      }
    }

    .controls-row {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .control-group {
      flex: 1;
    }

    label {
      display: block;
      font-size: 10px;
      font-weight: 500;
      margin-bottom: 4px;
      color: #333333;
    }

    input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 11px;
      font-family: inherit;
    }

    button {
      padding: 6px 12px;
      background: #18a0fb;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s;
      white-space: nowrap;
    }

    button:hover:not(:disabled) {
      background: #0d8ce8;
    }

    button:disabled {
      background: #d0d0d0;
      cursor: not-allowed;
    }

    button.secondary {
      background: #ffffff;
      color: #333333;
      border: 1px solid #d0d0d0;
    }

    button.secondary:hover:not(:disabled) {
      background: #f7f7f7;
    }

    .color-list-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .color-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .color-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .color-item:hover {
      border-color: #18a0fb;
      background: #f7f7f7;
    }

    .color-item.selected {
      border-color: #18a0fb;
      background: #e5f3ff;
    }

    .color-swatch {
      width: 40px;
      height: 40px;
      border-radius: 4px;
      flex-shrink: 0;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .color-swatch::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(0,0,0,0.1) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .color-item:hover .color-swatch {
      transform: scale(1.1);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.15);
    }

    .color-item:hover .color-swatch::before {
      opacity: 1;
    }

    .color-preview-tooltip {
      position: fixed;
      width: 120px;
      height: 120px;
      border-radius: 8px;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2), inset 0 0 0 2px rgba(255,255,255,0.5);
      opacity: 0;
      transition: opacity 0.2s ease;
      display: none;
    }

    .color-preview-tooltip.visible {
      opacity: 1;
      display: block;
    }

    .color-details {
      flex: 1;
      min-width: 0;
    }

    .color-name-input {
      width: 100%;
      padding: 4px 6px;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
      font-family: inherit;
      margin-bottom: 4px;
    }

    .color-name-input:focus {
      outline: none;
      border-color: #18a0fb;
    }

    .color-hex {
      font-size: 10px;
      color: #666666;
      font-family: 'Monaco', 'Courier New', monospace;
    }

    .wcag-badge {
      display: inline-block;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
      margin-left: 6px;
      font-family: 'Inter', sans-serif;
    }

    .wcag-white {
      background: #000000;
      color: #ffffff;
    }

    .wcag-black {
      background: #ffffff;
      color: #000000;
      border: 1px solid #d0d0d0;
    }

    .expand-btn {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666666;
      padding: 4px 8px;
      font-size: 10px;
      margin-top: 4px;
      width: 100%;
    }

    .expand-btn:hover {
      background: #f7f7f7;
      color: #333333;
    }

    .color-scale {
      display: none;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e5e5e5;
    }

    .color-scale.visible {
      display: block;
    }

    .scale-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(28px, 1fr));
      gap: 4px;
    }

    .scale-swatch {
      aspect-ratio: 1;
      border-radius: 3px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
      position: relative;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .scale-swatch:hover {
      transform: scale(1.15);
      z-index: 10;
    }

    .scale-swatch.extracted {
      box-shadow: inset 0 0 0 2px #18a0fb;
      outline: 2px solid #18a0fb;
      outline-offset: 2px;
    }

    .scale-swatch.selected {
      box-shadow: inset 0 0 0 3px #00ff00;
      outline: 3px solid #00ff00;
      outline-offset: 2px;
    }

    .scale-swatch.extracted::after {
      content: '‚óè';
      position: absolute;
      top: -8px;
      right: -8px;
      width: 16px;
      height: 16px;
      background: #18a0fb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: white;
      border: 2px solid white;
    }

    .scale-swatch.selected::after {
      content: '‚úì';
      position: absolute;
      top: -8px;
      right: -8px;
      width: 16px;
      height: 16px;
      background: #00ff00;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      color: white;
      border: 2px solid white;
    }

    .scale-label {
      position: absolute;
      bottom: 2px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 7px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .selection-checkbox {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .bottom-controls {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .bottom-controls button {
      flex: 1;
      padding: 10px;
    }

    .info-text {
      font-size: 10px;
      color: #666666;
      text-align: center;
      padding: 8px 16px;
      background: #f7f7f7;
      border-top: 1px solid #e5e5e5;
      flex-shrink: 0;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #999999;
      font-size: 11px;
      text-align: center;
      padding: 32px;
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <div class="header">
    <h2>Hextractor</h2>
  </div>

  <div class="main-container">
    <div class="left-panel">
      <div class="upload-area" id="uploadArea">
        <p class="upload-text">üìÅ Drop image or click</p>
        <p class="upload-subtext">PNG, JPG, WEBP</p>
        <input type="file" id="fileInput" accept="image/*">
      </div>

      <div class="controls-row">
        <div class="control-group">
          <label for="colorCount">Colors to extract</label>
          <input type="number" id="colorCount" min="2" max="20" value="8">
        </div>
        <button id="extractBtn" class="secondary" disabled>Extract</button>
      </div>

      <div class="control-group">
        <label>Naming Pattern</label>
        <input type="text" id="namingPattern" placeholder="e.g. Brand/Primary" 
               style="width: 100%; padding: 6px 8px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 11px;">
      </div>
    </div>

    <div class="right-panel">
      <div class="preview-container" id="previewContainer">
        <img id="imagePreview" alt="Preview">
        <div id="particleContainer" style="position: relative; display: none;"></div>
        <canvas id="clusterCanvas"></canvas>
      </div>

      <div class="color-list-container" id="colorListContainer">
        <div class="empty-state">
          <div class="empty-state-icon">üé®</div>
          <div>Upload an image and extract colors<br>to get started</div>
        </div>
        <div class="color-list" id="colorList"></div>
      </div>

      <div class="bottom-controls">
        <button id="selectAllBtn" style="flex: 0 0 auto; min-width: 80px;">Select All</button>
        <button id="saveBtn" disabled>Save as Figma Styles</button>
      </div>

      <div class="info-text" id="infoText"></div>
    </div>
  </div>

  <div class="color-preview-tooltip" id="colorTooltip"></div>

  <script>
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const imagePreview = document.getElementById('imagePreview');
    const clusterCanvas = document.getElementById('clusterCanvas');
    const particleContainer = document.getElementById('particleContainer');
    const previewContainer = document.getElementById('previewContainer');
    const extractBtn = document.getElementById('extractBtn');
    const saveBtn = document.getElementById('saveBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const colorList = document.getElementById('colorList');
    const colorListContainer = document.getElementById('colorListContainer');
    const colorCountInput = document.getElementById('colorCount');
    const namingPattern = document.getElementById('namingPattern');
    const infoText = document.getElementById('infoText');
    const colorTooltip = document.getElementById('colorTooltip');

    let currentImage = null;
    let extractedColors = [];
    let colorNames = [];
    let animationFrame = null;

    // Upload area interactions
    uploadArea.addEventListener('click', () => fileInput.click());
    
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        handleImageUpload(file);
      }
    });

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        handleImageUpload(file);
      }
    });

    function handleImageUpload(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        currentImage = e.target.result;
        imagePreview.src = currentImage;
        imagePreview.style.display = 'block';
        clusterCanvas.style.display = 'none';
        particleContainer.style.display = 'none';
        particleContainer.innerHTML = '';
        previewContainer.style.display = 'block';
        extractBtn.disabled = false;
        colorList.innerHTML = '';
        colorListContainer.querySelector('.empty-state').style.display = 'flex';
        saveBtn.disabled = true;
        infoText.textContent = '';
      };
      reader.readAsDataURL(file);
    }

    extractBtn.addEventListener('click', () => {
      if (!currentImage) return;
      
      extractBtn.disabled = true;
      extractBtn.textContent = 'Extracting...';
      infoText.textContent = 'Analyzing colors...';
      
      const img = new Image();
      img.onload = async () => {
        console.log('Image loaded, starting extraction...');
        
        // First, extract colors without animation
        const startTime = performance.now();
        const colors = await extractColorsQuick(img, parseInt(colorCountInput.value));
        console.log('Colors extracted in', Math.round(performance.now() - startTime), 'ms');
        
        // Then show the particle animation
        imagePreview.style.display = 'none';
        particleContainer.style.display = 'block';
        
        // Set container size to match image dimensions
        const imgWidth = imagePreview.naturalWidth;
        const imgHeight = imagePreview.naturalHeight;
        const maxWidth = previewContainer.clientWidth - 32; // Account for padding
        const maxHeight = 200;
        
        // Calculate scaled dimensions
        const scale = Math.min(maxWidth / imgWidth, maxHeight / imgHeight, 1);
        const displayWidth = imgWidth * scale;
        const displayHeight = imgHeight * scale;
        
        particleContainer.style.width = displayWidth + 'px';
        particleContainer.style.height = displayHeight + 'px';
        particleContainer.style.margin = '0 auto';
        particleContainer.style.backgroundColor = '#ffffff';
        particleContainer.style.border = '1px solid #e5e5e5';
        particleContainer.style.borderRadius = '4px';
        
        console.log('Container size:', displayWidth, displayHeight);
        
        infoText.textContent = 'Watch colors cluster...';
        
        const animStart = performance.now();
        await animateParticlesToCorners(img, colors, particleContainer);
        console.log('Animation completed in', Math.round(performance.now() - animStart), 'ms');
        
        // Show results
        extractedColors = colors;
        colorNames = colors.map((color, i) => {
          const colorName = getColorName(color);
          return `${colorName} ${i + 1}`;
        });
        
        displayColors(colors);
        extractBtn.disabled = false;
        extractBtn.textContent = 'Extract';
        saveBtn.disabled = false;
        infoText.textContent = `‚úì Extracted ${colors.length} colors`;
        
        // Add sparkles
        createSparkles();
        
        // Transition back to image after delay
        setTimeout(() => {
          particleContainer.style.display = 'none';
          imagePreview.style.display = 'block';
        }, 1000); // Keep it visible for 1 more second after animation
      };
      img.src = currentImage;
    });

    function extractColorsQuick(img, numColors) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const maxSize = 200;
        const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        
        const colorMap = new Map();
        for (let i = 0; i < pixels.length; i += 4) {
          const r = pixels[i];
          const g = pixels[i + 1];
          const b = pixels[i + 2];
          const a = pixels[i + 3];
          
          if (a < 128) continue;
          
          const key = `${r},${g},${b}`;
          colorMap.set(key, (colorMap.get(key) || 0) + 1);
        }
        
        const colors = Array.from(colorMap.entries())
          .map(([key, count]) => {
            const [r, g, b] = key.split(',').map(Number);
            return { r, g, b, count };
          })
          .sort((a, b) => b.count - a.count);
        
        // Quick k-means without animation
        let centroids = colors.slice(0, numColors).map(c => ({r: c.r, g: c.g, b: c.b}));
        
        for (let iter = 0; iter < 10; iter++) {
          const clusters = Array(numColors).fill(null).map(() => []);
          
          colors.forEach(color => {
            let minDist = Infinity;
            let closestIdx = 0;
            
            centroids.forEach((centroid, idx) => {
              const dist = colorDistance(color, centroid);
              if (dist < minDist) {
                minDist = dist;
                closestIdx = idx;
              }
            });
            
            clusters[closestIdx].push(color);
          });
          
          centroids = clusters.map(cluster => {
            if (cluster.length === 0) return centroids[0];
            
            const totalWeight = cluster.reduce((sum, c) => sum + c.count, 0);
            const r = cluster.reduce((sum, c) => sum + c.r * c.count, 0) / totalWeight;
            const g = cluster.reduce((sum, c) => sum + c.g * c.count, 0) / totalWeight;
            const b = cluster.reduce((sum, c) => sum + c.b * c.count, 0) / totalWeight;
            
            return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
          });
        }
        
        resolve(centroids);
      });
    }

    async function animateParticlesToCorners(img, colors, container) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const maxSize = 150;
        const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        
        // Get actual container dimensions
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        console.log('Container dimensions:', containerWidth, 'x', containerHeight);
        
        // Sample pixels - adjust rate for performance vs visual density
        const sampleRate = 3; // Every 3rd pixel (was 2)
        const particles = [];
        
        console.log('Sampling pixels from', canvas.width, 'x', canvas.height, 'canvas...');
        
        for (let y = 0; y < canvas.height; y += sampleRate) {
          for (let x = 0; x < canvas.width; x += sampleRate) {
            const i = (y * canvas.width + x) * 4;
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];
            
            if (a < 128) continue;
            
            // Find closest cluster
            let minDist = Infinity;
            let clusterIdx = 0;
            
            colors.forEach((color, idx) => {
              const dist = colorDistance({r, g, b}, color);
              if (dist < minDist) {
                minDist = dist;
                clusterIdx = idx;
              }
            });
            
            particles.push({
              x: (x / canvas.width) * containerWidth,
              y: (y / canvas.height) * containerHeight,
              color: rgbToHex(r, g, b),
              clusterIdx: clusterIdx
            });
          }
        }
        
        console.log('Generated', particles.length, 'particles');
        console.log('Starting particle animation...');
        
        const animStartTime = performance.now();
        
        // Calculate target positions for each cluster (but don't render boxes)
        const numColors = colors.length;
        const positions = calculateCornerPositions(numColors, containerWidth, containerHeight);
        
        console.log('Cluster positions:', positions);
        
        // Create and animate particles
        const particleElements = [];
        particles.forEach((particle, idx) => {
          const el = document.createElement('div');
          el.className = 'particle';
          el.style.backgroundColor = particle.color;
          el.style.left = particle.x + 'px';
          el.style.top = particle.y + 'px';
          
          const targetPos = positions[particle.clusterIdx];
          const tx = targetPos.x - particle.x;
          const ty = targetPos.y - particle.y;
          
          el.style.setProperty('--tx', tx + 'px');
          el.style.setProperty('--ty', ty + 'px');
          
          // Staggered animation start - very small stagger for smooth wave effect
          const delay = (idx % 500) * 0.5; // Only stagger within groups of 500
          el.style.animation = `particleFloat 3s ease-in-out ${delay}ms forwards`;
          
          container.appendChild(el);
          particleElements.push(el);
        });
        
        console.log('Created', particleElements.length, 'particle elements in', Math.round(performance.now() - animStartTime), 'ms');
        console.log('Particles will animate for 3000ms + max 250ms stagger = 3250ms total');
        
        // Animation duration is 3s + max 250ms stagger
        const totalAnimationTime = 3000 + 250;
        
        // Clean up after ALL animations complete
        setTimeout(() => {
          console.log('Cleaning up particles...');
          particleElements.forEach(el => el.remove());
          resolve();
        }, totalAnimationTime + 200); // Add 200ms buffer
      });
    }

    function calculateCornerPositions(numColors, width, height) {
      const positions = [];
      const cornerSize = 60; // Size of corner boxes
      
      if (numColors <= 4) {
        // Place in 4 corners
        positions.push({ x: 10, y: 10 });
        if (numColors > 1) positions.push({ x: width - cornerSize - 10, y: 10 });
        if (numColors > 2) positions.push({ x: 10, y: height - cornerSize - 10 });
        if (numColors > 3) positions.push({ x: width - cornerSize - 10, y: height - cornerSize - 10 });
      } else if (numColors <= 6) {
        // Top row and bottom row
        const topCount = Math.ceil(numColors / 2);
        const bottomCount = Math.floor(numColors / 2);
        const topSpacing = (width - cornerSize * topCount) / (topCount + 1);
        const bottomSpacing = (width - cornerSize * bottomCount) / (bottomCount + 1);
        
        for (let i = 0; i < topCount; i++) {
          positions.push({ x: topSpacing * (i + 1) + cornerSize * i, y: 10 });
        }
        for (let i = 0; i < bottomCount; i++) {
          positions.push({ x: bottomSpacing * (i + 1) + cornerSize * i, y: height - cornerSize - 10 });
        }
      } else {
        // Grid layout
        const cols = Math.ceil(Math.sqrt(numColors));
        const rows = Math.ceil(numColors / cols);
        const xSpacing = (width - cornerSize * cols) / (cols + 1);
        const ySpacing = (height - cornerSize * rows) / (rows + 1);
        
        for (let i = 0; i < numColors; i++) {
          const col = i % cols;
          const row = Math.floor(i / cols);
          positions.push({
            x: xSpacing * (col + 1) + cornerSize * col,
            y: ySpacing * (row + 1) + cornerSize * row
          });
        }
      }
      
      return positions;
    }

    function colorDistance(c1, c2) {
      const dr = c1.r - c2.r;
      const dg = c1.g - c2.g;
      const db = c1.b - c2.b;
      return Math.sqrt(2 * dr * dr + 4 * dg * dg + 3 * db * db);
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function getColorName(color) {
      const hsl = rgbToHsl(color.r, color.g, color.b);
      const h = hsl.h;
      const s = hsl.s;
      const l = hsl.l;

      if (s < 10) {
        if (l < 20) return 'Black';
        if (l < 40) return 'Dark Gray';
        if (l < 60) return 'Gray';
        if (l < 80) return 'Light Gray';
        return 'White';
      }

      if (h < 15) return 'Red';
      if (h < 45) return 'Orange';
      if (h < 70) return 'Yellow';
      if (h < 150) return 'Green';
      if (h < 200) return 'Cyan';
      if (h < 260) return 'Blue';
      if (h < 290) return 'Purple';
      if (h < 330) return 'Magenta';
      return 'Red';
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }

      return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
    }

    // OKLCH color space conversions (simplified implementation)
    function rgbToOKLCH(r, g, b) {
      // Normalize RGB to 0-1
      r /= 255; g /= 255; b /= 255;
      
      // Linear RGB
      const toLinear = (c) => c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      const rLin = toLinear(r);
      const gLin = toLinear(g);
      const bLin = toLinear(b);
      
      // OKLab (approximation)
      const l = 0.4122214708 * rLin + 0.5363325363 * gLin + 0.0514459929 * bLin;
      const m = 0.2119034982 * rLin + 0.6806995451 * gLin + 0.1073969566 * bLin;
      const s = 0.0883024619 * rLin + 0.2817188376 * gLin + 0.6299787005 * bLin;
      
      const l_ = Math.cbrt(l);
      const m_ = Math.cbrt(m);
      const s_ = Math.cbrt(s);
      
      const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
      const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
      const b_ = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;
      
      // Convert to LCH
      const C = Math.sqrt(a * a + b_ * b_);
      let H = Math.atan2(b_, a) * 180 / Math.PI;
      if (H < 0) H += 360;
      
      return { l: L, c: C, h: H };
    }

    function oklchToRGB(l, c, h) {
      // Convert LCH to Lab
      const hRad = h * Math.PI / 180;
      const a = c * Math.cos(hRad);
      const b_ = c * Math.sin(hRad);
      
      // OKLab to linear RGB
      const l_ = l + 0.3963377774 * a + 0.2158037573 * b_;
      const m_ = l - 0.1055613458 * a - 0.0638541728 * b_;
      const s_ = l - 0.0894841775 * a - 1.2914855480 * b_;
      
      const l3 = l_ * l_ * l_;
      const m3 = m_ * m_ * m_;
      const s3 = s_ * s_ * s_;
      
      let rLin = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
      let gLin = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
      let bLin = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;
      
      // Clamp to valid range
      rLin = Math.max(0, Math.min(1, rLin));
      gLin = Math.max(0, Math.min(1, gLin));
      bLin = Math.max(0, Math.min(1, bLin));
      
      // Convert to sRGB
      const toSRGB = (c) => c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1/2.4) - 0.055;
      const r = Math.round(toSRGB(rLin) * 255);
      const g = Math.round(toSRGB(gLin) * 255);
      const b = Math.round(toSRGB(bLin) * 255);
      
      return { r, g, b };
    }

    function generateOKLCHScale(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return null;
      
      const oklch = rgbToOKLCH(rgb.r, rgb.g, rgb.b);
      
      // Define lightness and chroma adjustments for each weight
      const scales = {
        50:  { l: 0.97, cMult: 0.15 },
        100: { l: 0.95, cMult: 0.25 },
        200: { l: 0.90, cMult: 0.40 },
        300: { l: 0.82, cMult: 0.60 },
        400: { l: 0.72, cMult: 0.80 },
        500: { l: oklch.l, cMult: 1.0 },  // Base color
        600: { l: oklch.l * 0.85, cMult: 0.96 },
        700: { l: oklch.l * 0.70, cMult: 0.92 },
        800: { l: oklch.l * 0.55, cMult: 0.88 },
        900: { l: oklch.l * 0.42, cMult: 0.84 },
        950: { l: oklch.l * 0.32, cMult: 0.80 }
      };
      
      const result = {};
      Object.entries(scales).forEach(([weight, { l, cMult }]) => {
        const scaledRGB = oklchToRGB(l, oklch.c * cMult, oklch.h);
        result[weight] = rgbToHex(scaledRGB.r, scaledRGB.g, scaledRGB.b);
      });
      
      return result;
    }

    // WCAG contrast calculation
    function getLuminance(r, g, b) {
      const [rs, gs, bs] = [r, g, b].map(c => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    }

    function getContrastRatio(rgb1, rgb2) {
      const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);
      const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);
      const brightest = Math.max(lum1, lum2);
      const darkest = Math.min(lum1, lum2);
      return (brightest + 0.05) / (darkest + 0.05);
    }

    function getWCAGTextColor(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return { color: 'black', ratio: 0 };
      
      const whiteContrast = getContrastRatio(rgb, { r: 255, g: 255, b: 255 });
      const blackContrast = getContrastRatio(rgb, { r: 0, g: 0, b: 0 });
      
      // WCAG AA requires 4.5:1 for normal text
      const bestColor = whiteContrast > blackContrast ? 'white' : 'black';
      const bestRatio = Math.max(whiteContrast, blackContrast);
      
      return { color: bestColor, ratio: bestRatio.toFixed(1) };
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function createSparkles() {
      const rect = previewContainer.getBoundingClientRect();
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      
      for (let i = 0; i < 12; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        
        const angle = (i / 12) * Math.PI * 2;
        const distance = 50 + Math.random() * 30;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        
        sparkle.style.left = centerX + 'px';
        sparkle.style.top = centerY + 'px';
        sparkle.style.setProperty('--tx', tx + 'px');
        sparkle.style.setProperty('--ty', ty + 'px');
        
        // Random colors from Figma blue palette
        const colors = ['#18a0fb', '#0d8ce8', '#7b61ff', '#00c4cc'];
        sparkle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        previewContainer.appendChild(sparkle);
        
        setTimeout(() => sparkle.remove(), 1000);
      }
    }

    function displayColors(colors) {
      colorListContainer.querySelector('.empty-state').style.display = 'none';
      colorList.innerHTML = '';
      
      colors.forEach((color, index) => {
        const hex = rgbToHex(color.r, color.g, color.b);
        const wcagResult = getWCAGTextColor(hex);
        const wcagText = wcagResult.color;
        const contrastRatio = wcagResult.ratio;
        const scale = generateOKLCHScale(hex);
        
        const colorItem = document.createElement('div');
        colorItem.className = 'color-item selected';
        colorItem.dataset.index = index;
        
        // Determine WCAG level
        const wcagLevel = contrastRatio >= 7 ? 'AAA' : contrastRatio >= 4.5 ? 'AA' : 'Fail';
        
        colorItem.innerHTML = `
          <div class="color-swatch" style="background-color: ${hex};"></div>
          <div class="color-details">
            <input type="text" class="color-name-input" value="${colorNames[index]}" data-index="${index}">
            <div class="color-hex">
              ${hex}
              <span class="wcag-badge wcag-${wcagText}" title="Contrast ratio: ${contrastRatio}:1 (WCAG ${wcagLevel})">Use ${wcagText} text (${contrastRatio}:1)</span>
            </div>
            <button class="expand-btn" data-index="${index}">View Scale (50-950)</button>
            <div class="color-scale" data-index="${index}">
              <div class="scale-grid" id="scale-${index}"></div>
            </div>
          </div>
          <input type="checkbox" class="selection-checkbox" checked data-index="${index}">
        `;
        
        const checkbox = colorItem.querySelector('.selection-checkbox');
        const nameInput = colorItem.querySelector('.color-name-input');
        const swatch = colorItem.querySelector('.color-swatch');
        const expandBtn = colorItem.querySelector('.expand-btn');
        const scaleContainer = colorItem.querySelector('.color-scale');
        const scaleGrid = colorItem.querySelector(`#scale-${index}`);
        
        // Populate scale grid
        if (scale) {
          // Find which scale swatch matches the extracted color (500 is usually the base)
          let extractedWeight = '500';
          let closestWeight = '500';
          let minDiff = Infinity;
          
          Object.entries(scale).forEach(([weight, scaleHex]) => {
            const diff = Math.abs(parseInt(scaleHex.slice(1), 16) - parseInt(hex.slice(1), 16));
            if (diff < minDiff) {
              minDiff = diff;
              closestWeight = weight;
            }
          });
          
          let selectedWeight = closestWeight; // Track currently selected weight
          
          Object.entries(scale).forEach(([weight, scaleHex]) => {
            const scaleSwatch = document.createElement('div');
            scaleSwatch.className = 'scale-swatch';
            scaleSwatch.style.backgroundColor = scaleHex;
            scaleSwatch.dataset.weight = weight;
            
            // Mark the extracted color
            if (weight === closestWeight) {
              scaleSwatch.classList.add('extracted', 'selected');
            }
            
            scaleSwatch.title = `${weight}: ${scaleHex} - Click to use this color`;
            scaleSwatch.innerHTML = `<div class="scale-label">${weight}</div>`;
            
            scaleSwatch.addEventListener('click', (e) => {
              e.stopPropagation();
              
              // Remove 'selected' class from all swatches in this scale
              scaleGrid.querySelectorAll('.scale-swatch').forEach(sw => {
                sw.classList.remove('selected');
              });
              
              // Add 'selected' class to clicked swatch
              scaleSwatch.classList.add('selected');
              selectedWeight = weight;
              
              // Update the main color swatch
              swatch.style.backgroundColor = scaleHex;
              
              // Update the hex display and WCAG
              const hexDisplay = colorItem.querySelector('.color-hex');
              const wcagResult = getWCAGTextColor(scaleHex);
              const wcagText = wcagResult.color;
              const contrastRatio = wcagResult.ratio;
              const wcagLevel = contrastRatio >= 7 ? 'AAA' : contrastRatio >= 4.5 ? 'AA' : 'Fail';
              
              hexDisplay.innerHTML = `
                ${scaleHex}
                <span class="wcag-badge wcag-${wcagText}" title="Contrast ratio: ${contrastRatio}:1 (WCAG ${wcagLevel})">Use ${wcagText} text (${contrastRatio}:1)</span>
              `;
              
              // Update the stored color
              const rgb = hexToRgb(scaleHex);
              extractedColors[index] = rgb;
              
              // Update tooltip color
              colorTooltip.style.backgroundColor = scaleHex;
              
              // Visual feedback
              scaleSwatch.style.transform = 'scale(1.3)';
              swatch.style.transform = 'scale(1.1)';
              setTimeout(() => {
                scaleSwatch.style.transform = '';
                swatch.style.transform = '';
              }, 200);
              
              // Copy to clipboard as well
              navigator.clipboard.writeText(scaleHex);
            });
            
            scaleGrid.appendChild(scaleSwatch);
          });
        }
        
        // Expand/collapse scale
        expandBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          scaleContainer.classList.toggle('visible');
          expandBtn.textContent = scaleContainer.classList.contains('visible') 
            ? 'Hide Scale' 
            : 'View Scale (50-950)';
        });
        
        // Add tooltip on hover
        swatch.addEventListener('mouseenter', (e) => {
          colorTooltip.style.backgroundColor = hex;
          colorTooltip.classList.add('visible');
        });
        
        swatch.addEventListener('mousemove', (e) => {
          colorTooltip.style.left = (e.clientX + 20) + 'px';
          colorTooltip.style.top = (e.clientY - 60) + 'px';
        });
        
        swatch.addEventListener('mouseleave', () => {
          colorTooltip.classList.remove('visible');
        });
        
        colorItem.addEventListener('click', (e) => {
          // Ignore clicks on these elements
          if (e.target === nameInput || 
              e.target === expandBtn || 
              e.target.classList.contains('scale-swatch') ||
              e.target.classList.contains('scale-label') ||
              e.target.classList.contains('scale-grid')) {
            return;
          }
          checkbox.checked = !checkbox.checked;
          colorItem.classList.toggle('selected', checkbox.checked);
          updateSaveButton();
        });
        
        checkbox.addEventListener('click', (e) => {
          e.stopPropagation();
          colorItem.classList.toggle('selected', checkbox.checked);
          updateSaveButton();
        });

        nameInput.addEventListener('input', (e) => {
          colorNames[index] = e.target.value;
        });

        nameInput.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        colorList.appendChild(colorItem);
      });

      updateSaveButton();
    }

    function updateSaveButton() {
      const checkedCount = document.querySelectorAll('.selection-checkbox:checked').length;
      saveBtn.disabled = checkedCount === 0;
      selectAllBtn.textContent = checkedCount === extractedColors.length ? 'Deselect All' : 'Select All';
    }

    selectAllBtn.addEventListener('click', () => {
      const allSelected = document.querySelectorAll('.selection-checkbox:checked').length === extractedColors.length;
      document.querySelectorAll('.selection-checkbox').forEach((cb, i) => {
        cb.checked = !allSelected;
        document.querySelector(`.color-item[data-index="${i}"]`).classList.toggle('selected', !allSelected);
      });
      updateSaveButton();
    });

    saveBtn.addEventListener('click', () => {
      const colorsToSave = [];
      document.querySelectorAll('.selection-checkbox:checked').forEach(cb => {
        const index = parseInt(cb.dataset.index);
        const color = extractedColors[index];
        const hex = rgbToHex(color.r, color.g, color.b);
        const pattern = namingPattern.value.trim();
        const name = pattern ? `${pattern}/${colorNames[index]}` : colorNames[index];
        colorsToSave.push({ hex, name });
      });
      
      parent.postMessage({
        pluginMessage: {
          type: 'save-colors',
          colors: colorsToSave
        }
      }, '*');
      
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    });

    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (msg.type === 'colors-saved') {
        infoText.textContent = `‚úì Successfully created ${msg.count} color styles!`;
        saveBtn.textContent = 'Save as Figma Styles';
        updateSaveButton();
      }
    };
  </script>
</body>
</html>
